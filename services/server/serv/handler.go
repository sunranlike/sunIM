package serv

import (
	"bytes"
	"github.com/sunrnalike/sun"
	"github.com/sunrnalike/sun/container"
	"github.com/sunrnalike/sun/logger"
	"github.com/sunrnalike/sun/wire"
	"github.com/sunrnalike/sun/wire/pkt"
	"google.golang.org/protobuf/proto"
	"strings"
	"time"
)

var log = logger.WithFields(logger.Fields{
	"service": wire.SNChat,
	"pkg":     "serv",
})

// ServHandler ServHandler
type ServHandler struct {
	r         *sun.Router
	cache     sun.SessionStorage
	dispather *ServerDispather
}

func NewServHandler(r *sun.Router, cache sun.SessionStorage) *ServHandler {
	return &ServHandler{
		r:         r,
		dispather: &ServerDispather{},
		cache:     cache,
	}
}

// Accept this connection
func (h *ServHandler) Accept(conn sun.Conn, timeout time.Duration) (string, error) {
	log.Infoln("enter")

	_ = conn.SetReadDeadline(time.Now().Add(timeout))
	frame, err := conn.ReadFrame()
	if err != nil {
		return "", err
	}

	var req pkt.InnerHandshakeReq
	_ = proto.Unmarshal(frame.GetPayload(), &req)
	log.Info("Accept -- ", req.ServiceId)

	return req.ServiceId, nil
}

// Receive default listener
func (h *ServHandler) Receive(ag sun.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)          //同样的,读取payload
	packet, err := pkt.MustReadLogicPkt(buf) //这里调用的是必须读logicPkt,因为这里肯定是逻辑协议了,
	//基础协议在网管那里就被拦截并且返回pong了
	if err != nil {
		log.Error(err)
		return
	}
	var session *pkt.Session                       //新建一个指针session
	if packet.Command == wire.CommandLoginSignIn { //判断如果是登录服务,则要生成session,
		//如果不是登录,就直接从channel中获取session
		server, _ := packet.GetMeta(wire.MetaDestServer)
		session = &pkt.Session{ //给他一个session
			ChannelId: packet.ChannelId,
			GateId:    server.(string),
			Tags:      []string{"AutoGenerated"},
		}
	} else { //非登录服务--直接通过channel的session登录
		// TODO：优化点
		session, err = h.cache.Get(packet.ChannelId) //冲频道中直接获取session
		if err == sun.ErrSessionNil {                //无session
			_ = RespErr(ag, packet, pkt.Status_SessionNotFound)
			return
		} else if err != nil {
			_ = RespErr(ag, packet, pkt.Status_SystemException)
			return
		}
	}
	log.Debugf("recv a message from %s  %s", session, &packet.Header)
	err = h.r.Serve(packet, h.dispather, h.cache, session) //通过session和cahce直接获取
	if err != nil {
		log.Warn(err)
	}

}

func RespErr(ag sun.Agent, p *pkt.LogicPkt, status pkt.Status) error {
	packet := pkt.NewFrom(&p.Header)
	packet.Status = status
	packet.Flag = pkt.Flag_Response

	return ag.Push(pkt.Marshal(packet))
}

type ServerDispather struct {
}

func (d *ServerDispather) Push(gateway string, channels []string, p *pkt.LogicPkt) error {
	p.AddStringMeta(wire.MetaDestChannels, strings.Join(channels, ","))
	return container.Push(gateway, p)
}

// Disconnect default listener
func (h *ServHandler) Disconnect(id string) error {
	logger.Warnf("close event of %s", id)
	return nil
}
